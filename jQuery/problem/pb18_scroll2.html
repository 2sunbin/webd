<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>페이지 스크롤</title>
    <link rel="stylesheet" href="reset.css">
    <script src="https://code.jquery.com/jquery.min.js"></script>
    <style>
        /* page를 뷰포트의 넓이 만큼 잡아주고 싶으면 그 위의 컨테이닝 블록까지 100%를 줘야 함(아래처럼)
         * html, body {height:100%; } .page{height: 100%} 
         */
        .page{
            height: 100vh;
            position: relative;
        }
        .page:nth-child(even) {
            background-color: #88bb8d;
        }
        .page > h2 {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);

            font-size: 500px;
            font-weight: 900;
        }
    </style>
    <script>
        $(function(){
            // 이벤트 핸들러: document 객체에서 ready 이벤트가 발생하면 실행할 기능
            // -> HTML 문서를 읽어들인 후 해석하고 DOM 구축을 끝낸 이후에 발생하는 이벤트

            // ★페이지 스크롤링
            // 0. 마우스 휠을 굴리면
            // 1. 마우스 휠 버튼을 아래로 굴리면
            // 1-2. 다음 페이지로 스크롤
            // 2. 마우스 휠 버튼을 위로 굴리면
            // 2-2. 이전 페이지로 스크롤
            // ---------------------------------------------------------

            // 프로그램에서 참조하는 jQuery 객체 미리 생성
            const $html = $('html');
            const $window = $(window);

            // 뷰포트에 표시되는 페이지 인덱스
            // let pageIndex = 0;

            
            // 뷰포트 높이
            let $windowHeight = $window.height();
            
            // 새로고침을 하면 현재 스크롤 위치를 확인해서 변수 pageIndex를 설정
            let pageIndex = Math.round($window.scrollTop() / $windowHeight);
            // -> Math 객체의 round 메서드는 인자를 반올림해서 정수 반환

            // 마지막 페이지 인덱스
            const lastPageIndex = $('.page').length - 1;

            // 1. 페이지가 새로고침 되었을 때 맨 위로 올리기
            // $window.scrollTop(0); -> 이거 안돼 이유는 ready 이벤트가 발생한 이후에 바로 실행되어야 하는데 빨리빨리가 안돼. 실패.
            // 10ms라는 애는 순식간에 실행되는 건데 컴퓨터 입장에선 아주 긴 시간이라 그 다음에 scrollTop을 주는거야
            // $html.animate({scrollTop: 0}, 10); 

            // 2. 페이지가 새로고침 되었을 때 보던 페이지에서 새로고침 되기(pageIndex 활용) -> 53번째 줄

            // 페이지가 중간에 걸친 경우, 페이지 상단에 맞춰 스크롤
            $html.animate({scrollTop:pageIndex * $windowHeight}, 10);

        

            // 0. 마우스 휠을 굴리면
            window.addEventListener('wheel', function(event){
                // 기본 이벤트 제거(휠 기본 이벤트 제거를 완벽히 하려면 passive:false도 줘야 함)
                event.preventDefault();

                // animate 메서드로 생성한 효과가 진행하는 동안, wheel 이벤트가 발생하면
                // 이벤트 핸들러 종료
                // is 선택자를 사용해서 animated 효과가 진행 중인지 확인해서 진행 중이면 종료
                if($html.is(':animated')) return;

                
                
                // A. 이동할 페이지 인덱스 계산
                // 1. 마우스 휠 버튼을 아래로 굴리면
                if(event.deltaY > 0){
                    // 마지막 페이지의 다음 페이지는 없으므로 이벤트 핸들러 종료
                    if(pageIndex >= lastPageIndex) return;
                    

                    // 1-2. 다음 페이지로 스크롤
                    pageIndex++;
    
                }
                // 2. 마우스 휠 버튼을 위로 굴리면
                else if(event.deltaY < 0){
                    // 첫 페이지의 이전 페이지는 없으므로 이벤트 핸들러 종료
                    if(pageIndex == 0) return;
                    
                    // 2-2. 이전 페이지로 스크롤
                    pageIndex--;
                }

                // B. 스크롤 할 위치 계산
                // -> 뷰포트 높이 * 이동할 페이지 인덱스
                const posTop = $windowHeight * pageIndex;

                // C. 위에서 계산한 위치로 스크롤
                $html.animate({scrollTop: posTop});

                // wheel 이벤트가 연달아 여러번 발생하는 경우(큐에 계속 쌓여서 마우스 휠을 빠르게 돌리고 놔도 계속 이벤트가 발생)
                // $html.stop().animate({scrollTop: posTop}); -> stop 메서드는 효율적인 메서드가 아니야(갈팡질팡하는 게 보여). 실패.
                // $html.animate({scrollTop: posTop}, {queue: false}); -> queue도 안돼(갈팡질팡하는 게 보여). 실패.
                // $html.clearQueue().animate({scrollTop: posTop}); -> clearQueue 안돼(갈팡질팡하는 게 보여). 실패.
                // 기본 이벤트 제거 아래쪽에 정리해놓음

            }, {passive: false});
            
            // 뷰포트의 크기가 바뀌면 뷰포트의 높이를 나타내는 변수 windowHeight를 다시 설정(중간에 창 크기를 바꾸는 사람도 있을 수 있으니까)
            window.addEventListener('resize', function(){
                $windowHeight = $window.height();
                // 창 크기가 변하면 적절한 위치로 다시 스크롤
                $html.animate({scrollTop: posTop}, 200);
            });
        });
    </script>
</head>
<body>
    <!-- 브라우저 화면을 가득 채우는 페이지 여러 개로 구성된 HTML 작성 -->
    <!-- 마우스 휠을 아래로 굴리면 다음 페이지로, 위로 굴리면 이전 페이지로 부드럽게 스크롤 하는 Javascript -->
    
    <div class="page">
        <h2>1</h2>
    </div>
    <div class="page">
        <h2>2</h2>
    </div>
    <div class="page">
        <h2>3</h2>
    </div>
    <div class="page">
        <h2>4</h2>
    </div>
    <div class="page">
        <h2>5</h2>
    </div>

    <a href="#" id="top">맨 위</a>
</body>
</html>